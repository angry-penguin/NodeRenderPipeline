#include "Packages/com.arycama.noderenderpipeline/ShaderLibrary/Lighting.hlsl"

#pragma kernel Transmittance KERNEL=Transmittance TRANSMITTANCE
#pragma kernel MultiScatter KERNEL=MultiScatter MULTI_SCATTER

RWTexture2D<float3> Result;
float2 _ScaleOffset;
uint _SampleCount;

static const uint _ThreadCount = 64;

groupshared float3 MultiScatterShared[_ThreadCount], ScatterShared[_ThreadCount];

[numthreads(_ThreadCount, 1, 1)]
void KERNEL(uint2 id : SV_DispatchThreadID, uint2 groupId : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
	#ifdef TRANSMITTANCE
		float2 uv = id * _ScaleOffset;
		float2 skyParams = UvToSkyParams(uv);
		float3 V = float3(SinFromCos(skyParams.x), skyParams.x, 0.0);
		float3 L = 0.0;
	#else
		float2 uv = groupId * _ScaleOffset;
		float2 skyParams = UvToSkyParams(uv);
		float3 L = float3(SinFromCos(skyParams.x), skyParams.x, 0.0);
		float2 u = Hammersley2dSeq(groupIndex, _ThreadCount);
		float3 V = SampleSphereUniform(u.x, u.y);
	#endif
	
	float viewHeight = skyParams.y;
	float3 luminance = 0.0, multiScatter = 0.0, transmittance = 1.0;
	
	// Compute the distance to the top atmosphere boundary along the view ray,
    // assuming the viewer is in space (or NaN if the view ray does not intersect the atmosphere).
	float dx;
	if (RayIntersectsGround(viewHeight, V.y))
	{
		float discriminant = viewHeight * viewHeight * (V.y * V.y - 1.0) + _PlanetRadius * _PlanetRadius;
		dx = -viewHeight * V.y - sqrt(discriminant);
	}
	else
	{
		float discriminant = viewHeight * viewHeight * (V.y * V.y - 1.0) + _TopRadius * _TopRadius;
		dx = -viewHeight * V.y + sqrt(discriminant);
	}
	
	dx /= _SampleCount;
	
	for (float i = 0.5; i < _SampleCount; i++)
	{
		float d = i * dx;
		float centerDist = sqrt(d * d + 2.0 * viewHeight * V.y * d + viewHeight * viewHeight);
			
		float4 extinctionCombined = saturate(exp2(centerDist * _AtmosphereExtinctionScale + _AtmosphereExtinctionOffset));
		float3 extinction = extinctionCombined.xyz + extinctionCombined.w + max(0.0, _OzoneAbsorption - abs(centerDist * _AtmosphereOzoneScale + _AtmosphereOzoneOffset));
		
		float LdotV = dot(V, L);
		float sunAngle = (viewHeight * L.y + d * LdotV) / centerDist;
		if (!RayIntersectsGround(centerDist, sunAngle))
		{
			float2 uv = TransmittanceUv(centerDist, sunAngle);
			float3 transmittanceToAtmosphere = _AtmosphereTransmittance.SampleLevel(_LinearClampSampler, uv, 0.0);
			
			float4 scatter = saturate(exp2(centerDist * _AtmosphereExtinctionScale + _AtmosphereScatterOffset));
			float3 lighting = RayleighPhaseFunction(LdotV) * transmittanceToAtmosphere * scatter.xyz;
			lighting += CornetteShanksPhasePartVarying(_MiePhase, LdotV) * _MiePhaseConstant * transmittanceToAtmosphere * scatter.w;
			luminance += transmittance * lighting * (1.0 - exp(-extinction * dx)) / extinction;
			
			multiScatter += transmittance * (scatter.xyz + scatter.w) * (1.0 - exp(-extinction * dx)) / extinction;
		}
		
		transmittance *= exp(-extinction * dx);
	}
	
		// Account for bounced light off the earth
	if (RayIntersectsGround(viewHeight, V.y))
	{
		float d = dx * _SampleCount;
		float centerDist = sqrt(d * d + 2.0 * viewHeight * V.y * d + viewHeight * viewHeight);

		float LdotV = dot(V, L);
		float NdotL = (viewHeight * L.y + d * LdotV) / centerDist;
		float3 sunTransmittance = TransmittanceToAtmosphere(_PlanetRadius, NdotL, _LinearClampSampler);
		luminance += sunTransmittance * transmittance * saturate(NdotL) * _GroundColor / PI;
	}
	
	#ifdef TRANSMITTANCE
		Result[id] = transmittance;
	#endif
	
	#ifdef MULTI_SCATTER
		ScatterShared[groupIndex] = luminance;
		MultiScatterShared[groupIndex] = multiScatter;

		for (uint s = 32; s > 0; s >>= 1)
		{
			GroupMemoryBarrierWithGroupSync();
		
			if (groupIndex < s)
			{
				ScatterShared[groupIndex] = (ScatterShared[groupIndex] + ScatterShared[groupIndex + s]) * 0.5;
				MultiScatterShared[groupIndex] = (MultiScatterShared[groupIndex] + MultiScatterShared[groupIndex + s]) * 0.5;
			}
		}
	
		if (groupIndex == 0)
			Result[groupId] = ScatterShared[0] / (1.0 - MultiScatterShared[0] / (4.0 * PI));
	#endif
}
