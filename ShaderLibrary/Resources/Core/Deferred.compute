#pragma kernel Deferred

#define REFLECTION_PROBE_RENDERING

#include "Packages/com.arycama.noderenderpipeline/ShaderLibrary/Brdf.hlsl"
#include "Packages/com.arycama.noderenderpipeline/ShaderLibrary/Packing.hlsl"

Buffer<float> _SkyVisibilitySh;
RWTexture2D<float3> Result;
TextureCube<float4> _GBuffer0, _GBuffer1;
TextureCube<float3> _GBuffer2;
TextureCube<float> Depth;
float4x4 _PixelCoordToViewDirWS;

float3 AmbientLightSimple(float3 N)
{
	float4 shAr = _AmbientSh[0];
	float4 shAg = _AmbientSh[1];
	float4 shAb = _AmbientSh[2];
	float4 shBr = _AmbientSh[3];
	float4 shBg = _AmbientSh[4];
	float4 shBb = _AmbientSh[5];
	float4 shC = _AmbientSh[6];
	
	float3 irradiance = 0.0;
	irradiance.r = dot(shAr.xyz, N) + shAr.w;
	irradiance.g = dot(shAg.xyz, N) + shAg.w;
	irradiance.b = dot(shAb.xyz, N) + shAb.w;
	
    // 4 of the quadratic (L2) polynomials
	float4 vB = N.xyzz * N.yzzx;
	irradiance.r += dot(shBr, vB);
	irradiance.g += dot(shBg, vB);
	irradiance.b += dot(shBb, vB);

    // Final (5th) quadratic (L2) polynomial
	float vC = N.x * N.x - N.y * N.y;
	irradiance += shC.rgb * vC;
	
	return irradiance;
}


float3 GetLighting1(float4 positionCS, float3 N, float3 T, PbrInput input)
{
	float3 positionWS = PixelToWorld(positionCS.xyz);

	float skyVisibility = _SkyVisibilitySh[0];
	skyVisibility += _SkyVisibilitySh[1] * N.y;
	skyVisibility += _SkyVisibilitySh[2] * N.z;
	skyVisibility += _SkyVisibilitySh[3] * N.x;
	skyVisibility += _SkyVisibilitySh[4] * N.y * N.x;
	skyVisibility += _SkyVisibilitySh[5] * N.y * N.z;
	skyVisibility += _SkyVisibilitySh[6] * (3.0 * N.z * N.z - 1.0);
	skyVisibility += _SkyVisibilitySh[7] * N.x * N.z;
	skyVisibility += _SkyVisibilitySh[8] * (N.x * N.x - N.y * N.y);
	
	float3 luminance = input.albedo * AmbientLight(N, 1.0, 1.0) * skyVisibility;
	
	for (uint i = 0; i < _DirectionalLightCount; i++)
	{
		DirectionalLightData lightData = _DirectionalLightData[i];
    
		// Earth shadow 
		float2 intersections;
		if (IntersectRaySphere(positionWS + _PlanetOffset, lightData.Direction, _PlanetRadius, intersections) && intersections.x >= 0.0)
			continue;
    
		float3 lightColor = TransmittanceToAtmosphere(positionWS + _PlanetOffset, lightData.Direction) * ApplyExposure(lightData.Color);
		//luminance += input.albedo * saturate(dot(N, lightData.Direction)) * RcpPi * lightColor;
	}
	
	return luminance;
}

float3 GBufferNormal(float4 data)
{
	return UnpackNormalOctQuadEncode(2.0 * Unpack888ToFloat2(data.xyz) - 1.0);
}

[numthreads(8, 8, 1)]
void Deferred (uint2 id : SV_DispatchThreadID)
{	
	float3 V = -MultiplyVector(_PixelCoordToViewDirWS, float3(id + 0.5, 1.0), false);
	
	float depth = Depth.SampleLevel(_PointClampSampler, V, 0.0);
	if(depth == _FarClipValue)
	{
		// If depth is empty, just render the sky. 
		Result[id] = _SkyReflection.SampleLevel(_LinearClampSampler, V, 0.0);
		return;
	}
	
	SurfaceData surface = DefaultSurface();
	
	// Load surface data from gbuffer
	float4 gbuffer0 = _GBuffer0.SampleLevel(_PointClampSampler, V, 0.0);;
	float4 gbuffer1 = _GBuffer1.SampleLevel(_PointClampSampler, V, 0.0);
	float3 normalWS = GBufferNormal(gbuffer1);
	
	surface.Albedo = gbuffer0.rgb;
	surface.Metallic = 0.0;
	surface.Normal = normalWS;
	surface.PerceptualRoughness = 1.0;
	surface.tangentWS = GetLocalFrame(normalWS)[0];
	surface.Emission = _GBuffer2.SampleLevel(_PointClampSampler, V, 0.0);

	// Pixel to world
	float linearEyeDepth = LinearEyeDepth(depth);
	
	PbrInput input = SurfaceDataToPbrInput(surface);
	float3x3 frame = GetLocalFrame(surface.Normal);
	float3 tangentWS = frame[0] * dot(surface.tangentWS, frame[0]) + frame[1] * dot(surface.tangentWS, frame[1]);
	
	// Apply exposure for reflection emission, as we don't apply exposure when it is captured
	surface.Emission = ApplyExposure(surface.Emission);
	
	float4 positionCS = float4(id + 0.5, depth, linearEyeDepth);
	Result[id] = GetLighting1(positionCS, surface.Normal, tangentWS, input) + surface.Emission;
}