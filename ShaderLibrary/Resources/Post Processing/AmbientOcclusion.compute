#include "Packages/com.arycama.noderenderpipeline/ShaderLibrary/Lighting.hlsl"
#include "Packages/com.arycama.noderenderpipeline/ShaderLibrary/Deferred.hlsl"
#include "Packages/com.arycama.noderenderpipeline/ShaderLibrary/Geometry.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/ImageBasedLighting.hlsl"

#pragma kernel Compute
#pragma kernel GenerateMips
#pragma kernel Temporal
#pragma kernel Spatial
#pragma kernel Combine
#pragma enable_d3d11_debug_symbols

RWTexture2D<float4> _VisibilityCone;
RWTexture2D<float> _FrameCountResult;
RWTexture2D<float4> _Result;
Texture2D<float4> _Input, _History;
Texture2D<float3> _PreviousFrame;
Texture2D<float> _Depth, _PreviousDepth, _FrameCountPrevious, _FrameCount;
Texture2D<uint> _Motion;

cbuffer AOConstants
{
	float4 _UvToView;
	float _SampleCount, _Strength, _ThinOccluderCompensation, _MaxScreenRadius, _FalloffScale, _FalloffBias, _Radius, _SampleDistributionPower, _DepthMipSamplingOffset, _MaxMips, _ClampWindowScale, _DepthRejection, _DepthWeight, _VelocityRejection, _ClampVelocityWeight, _AccumFrameCount, _DirectionCount, _WorldRadius;
	float _DistanceWeight, _NormalWeight, _TangentWeight;
	uint _BlurSamples;
	uint _MaxWidth, _MaxHeight;
};

// Inputs are screen XY and viewspace depth, output is viewspace position
float3 ComputeViewspacePosition(float2 screenPos, float viewspaceDepth)
{
	float3 ret;
	ret.xy = (screenPos * _ScreenSize.zw * _UvToView.xy + _UvToView.zw) * viewspaceDepth;
	ret.z = viewspaceDepth;
	return ret;
}

float4 PackOutput(float4 input)
{
	input /= 1.5;
	input.xyz = 0.5 * input.xyz + 0.5;
	return input;
}

float4 UnpackInput(float4 input)
{
	input.xyz = 2.0 * input.xyz - 1.0;
	return input * 1.5;
}

[numthreads(8, 8, 1)]
void Compute(uint2 id : SV_DispatchThreadID)
{
	float2 pixelCenter = floor(2 * id + 1 + _Jitter * 0.5) + 0.5;
	
	float3 N = GBufferNormal(pixelCenter);
	float3 normalV = WorldToViewDir(N, true);
	float2 noise = _BlueNoise2D[id % 128];

	float viewspaceZ = LinearEyeDepth(_Depth[pixelCenter], _ZBufferParams);
	float3 cPosV = ComputeViewspacePosition(pixelCenter, viewspaceZ);
	float3 viewV = normalize(-cPosV);

	float screenspaceRadius = min(_MaxScreenRadius, _Radius / viewspaceZ);
	float ratio = saturate(_MaxScreenRadius / (_Radius / viewspaceZ));
	
	float4 result = 0.0;
	for (float i = 0; i < _DirectionCount; i++)
	{
		float phi = PI / _DirectionCount * (i + noise.x);
		float3 directionV = float3(cos(phi), sin(phi), 0.0);
		
		float3 orthoDirectionV = ProjectOnPlane(directionV, viewV);
		float3 axisV = normalize(cross(directionV, viewV));
		float3 projNormalV = ProjectOnPlane(normalV, axisV);
	
		float sgnN = sign(dot(orthoDirectionV, projNormalV));
		float cosN = saturate(dot(projNormalV, viewV) / length(projNormalV));
		float n = sgnN * FastACos(cosN);
		
		float2 h;
		
		[unroll]
		for (uint side = 0; side < 2; side++)
		{
			// Find the intersection with the next pixel, and use that as the starting point for the ray
			float2 direction = directionV.xy * (2.0 * side - 1.0);
			float2 cell = floor(pixelCenter);
			float2 tMin = (cell - pixelCenter) / direction;
			float2 tMax = (cell - pixelCenter + 1.0) / direction;
			float t = Max2(max(tMin, tMax));
			float2 start = pixelCenter + direction * t;
			float2 end = pixelCenter + direction * screenspaceRadius;
			float2 step = (end - start) / _SampleCount;
			
			float lowHorizonCos = cos(n + (2.0 * side - 1.0) * HALF_PI);
			float cHorizonCos = lowHorizonCos;
			
			for (float j = 0.0; j < _SampleCount; j++)
			{
				float2 position = start + (j + noise.y) * step;
				float SZ = LinearEyeDepth(_Depth[position], _ZBufferParams);
				float3 sPosV = ComputeViewspacePosition(position, SZ);
				float3 sHorizonV = normalize(sPosV - cPosV);

				// Falloff
				float start = _WorldRadius * 0.75 * ratio;
				float end = _WorldRadius * ratio;
				float weight = saturate((end - distance(sPosV, cPosV)) / (end - start));
				float sHorizonCos = lerp(lowHorizonCos, dot(sHorizonV, viewV), weight);
			
				if (sHorizonCos >= cHorizonCos)
				{
					// If weighted horizon is greater than the previous sample, it becomes the new horizon
					cHorizonCos = sHorizonCos;
				}
				else if (dot(sHorizonV, viewV) < cHorizonCos)
				{
					// Otherwise, reduce the max horizon to attenuate thin features, but only if the -non- weighted sample is also below the current sample
					// This prevents the falloff causing objects to be treated as thin when they would not be otherwise
					cHorizonCos = max(lowHorizonCos, cHorizonCos - _ThinOccluderCompensation);
				}
			}

			h[side] = n + clamp((2.0 * side - 1.0) * FastACos(cHorizonCos) - n, -HALF_PI, HALF_PI);
			result.w += length(projNormalV) * (cosN + 2.0 * h[side] * sin(n) - cos(2.0 * h[side] - n)) / 4.0;
		}
		
		// see "Algorithm 2 Extension that computes bent normals b."
		float t0 = (6 * sin(h[0] - n) - sin(3 * h[0] - n) + 6 * sin(h[1] - n) - sin(3 * h[1] - n) + 16 * sin(n) - 3 * (sin(h[0] + n) + sin(h[1] + n))) / 12;
		float t1 = (-cos(3 * h[0] - n) - cos(3 * h[1] - n) + 8 * cos(n) - 3 * (cos(h[0] + n) + cos(h[1] + n))) / 12;
	
		float3 bentNormalL = normalize(float3(directionV.x * t0, directionV.y * t0, -t1));
		result.xyz += mul(RotFromToMatrix(float3(0, 0, -1), viewV), bentNormalL) * length(projNormalV);
	}
	
	result /= _DirectionCount;
		
	result.xyz = ViewToWorldDir(result.xyz, false);
	_Result[id] = PackOutput(result);
}

RWTexture2D<float4> _Result0, _Result1, _Result2, _Result3, _Result4;
uint _Width, _Height;
groupshared float4 _ResultShared[32][32];

[numthreads(32, 32, 1)]
void GenerateMips(uint2 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
	// Each thread reads 2x2 values and writes them into shared memory. 
	uint2 coord = groupId * 15 + groupThreadId;
	_ResultShared[groupThreadId.y][groupThreadId.x] = _Result0[coord];

	GroupMemoryBarrierWithGroupSync();
	
	float4 result = 0.0;
	if (all(groupThreadId < 15))
	{
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 1] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 1] * 0.25;
		
		if (all(groupThreadId < 8))
			_Result1[groupId * 8 + groupThreadId] = result;
	}

	GroupMemoryBarrierWithGroupSync();
	
	if (all(groupThreadId < 15))
		_ResultShared[groupThreadId.y][groupThreadId.x] = result;
	
	GroupMemoryBarrierWithGroupSync();
	
	result = 0.0;
	if (all(groupThreadId < 7))
	{
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 1] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 1] * 0.25;
		
		if (all(groupThreadId < 4))
			_Result2[groupId * 4 + groupThreadId] = result;
	}

	GroupMemoryBarrierWithGroupSync();
	
	if (all(groupThreadId < 7))
		_ResultShared[groupThreadId.y][groupThreadId.x] = result;
	
	GroupMemoryBarrierWithGroupSync();
	
	result = 0.0;
	if (all(groupThreadId < 3))
	{
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 1] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 1] * 0.25;
		
		if (all(groupThreadId < 2))
			_Result3[groupId * 2 + groupThreadId] = result;
	}

	GroupMemoryBarrierWithGroupSync();
	
	if (all(groupThreadId < 3))
		_ResultShared[groupThreadId.y][groupThreadId.x] = result;
	
	GroupMemoryBarrierWithGroupSync();
	
	result = 0.0;
	if (all(groupThreadId < 1))
	{
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 0] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 0][groupThreadId.x * 2 + 1] * 0.25;
		result += _ResultShared[groupThreadId.y * 2 + 1][groupThreadId.x * 2 + 1] * 0.25;
		_Result4[groupId + groupThreadId] = result;
	}
}

[numthreads(8, 8, 1)]
void Temporal(uint2 id : SV_DispatchThreadID)
{
	float2 uv = (id + 0.5) * _ScreenSize.zw;
	
	float4 result = 0.0;
	uint mip = 0;
	float2 mipResolution = uint2(_Width, _Height) >> mip;
	
	uint2 floorUv = uint2(uv * mipResolution - 0.5);
	
	// Get the depth which is closest to the full res depth, then weigh the samples based on that
	float fullResDepth = LinearEyeDepth(_Depth[id], _ZBufferParams);
	float4 depths;
	
	[unroll]
	for (uint y = 0, i = 0; y < 2; y++)
	{
		[unroll]
		for (uint x = 0; x < 2; x++, i++)
		{
			uint2 coord = floorUv + uint2(x, y);
			depths[i] = LinearEyeDepth(_Depth.mips[mip + 1][coord], _ZBufferParams);
		}
	}
	
	float4 deltas = abs(depths - fullResDepth);
	float closestDepth = Min4(deltas);
	float4 depthWeights = exp2(-Square(deltas - closestDepth) * (_DepthWeight / fullResDepth));
	
	float2 fracUv = frac(uv * mipResolution - 0.5);
	
	float4 weights;
	weights.x = (1.0 - fracUv.x) * (1.0 - fracUv.y);
	weights.y = fracUv.x * (1.0 - fracUv.y);
	weights.z = (1.0 - fracUv.x) * fracUv.y;
	weights.w = fracUv.x * fracUv.y;
	
	float weightSum = 0.0;
	float4 minValue = 0.0, maxValue = 0.0;
	
	[unroll]
	for (uint y = 0, i = 0; y < 2; y++)
	{
		[unroll]
		for (uint x = 0; x < 2; x++, i++)
		{
			uint2 coord = floorUv + uint2(x, y);
			float4 color = _Input.mips[mip][coord];
			float sampleDepth = LinearEyeDepth(_Depth.mips[mip][coord], _ZBufferParams);
			
			float weight = weights[i] * depthWeights[i];
			result += color * weight;
			weightSum += weight;
			
			if(i == 0)
				minValue = maxValue = color;
			else
			{
				minValue = min(minValue, color);
				maxValue = max(maxValue, color);
			}
		}
	}
	
	if(weightSum > 0.0)
		result /= weightSum;
	
	float2 motion = UnpackVelocity(_Motion[id]);
	float2 previousUv = uv - motion;
	
	if(all(saturate(previousUv) == previousUv))
	{
		float4 history = _History.SampleLevel(_LinearClampSampler, uv - motion, 0.0);
		float4 window = (maxValue - minValue) * _ClampWindowScale;
		history = clamp(history, minValue - window, maxValue + window);
		result = lerp(history, result, 0.05);
	}
	
	_Result[id] = result;
}

[numthreads(8, 8, 1)]
void Spatial(uint2 dispatchThreadId : SV_DispatchThreadID, uint2 groupThreadId : SV_GroupThreadID, uint2 groupId : SV_GroupID)
{
	float frameCount = _FrameCount[dispatchThreadId] * 255.0;
	float phi = _BlueNoise1D[dispatchThreadId % 128] * TWO_PI;
	float depth = _Depth[dispatchThreadId];
	float3 positionWS = PixelToWorld(dispatchThreadId + 0.5, depth);
 
	float4 result = UnpackInput(_Input[dispatchThreadId]);
	float weightSum = 1.0;
	
	float3 normal = GBufferNormal(dispatchThreadId);
	float3x3 frame = GetLocalFrame(normal);
	
	float rcpEyeDepth = rcp(LinearEyeDepth(depth, _ZBufferParams));
	float ratio = saturate(_MaxScreenRadius / (_Radius * rcpEyeDepth));
	float radius = _WorldRadius * ratio;
	
	// Tangent plane
	float4 plane = float4(normal, -dot(normal, positionWS));
	
	for (uint i = 0; i < _BlurSamples; i++)
	{
		float3 p = float3(radius * VogelDiskSample(i, _BlurSamples, phi, 2.0), 0.0);
		float3 samplePosition = mul(p, frame) + positionWS;
		
		float2 pixel = floor(WorldToPixel(samplePosition, false)) + 0.5;
		
		// Flip the offset for out of bounds pixels, rather than discarding or clamping them
		bool2 flip = pixel < 0.0 || pixel >= _ScreenSize.xy;
		p.xy = flip ? -p.xy : p.xy;
		samplePosition = mul(p, frame) + positionWS;
		pixel = floor(WorldToPixel(samplePosition, false)) + 0.5;
		
		float sampleDepth = _Depth[pixel];
		float3 sampleWorldPos = PixelToWorld(pixel + 0.5, sampleDepth);
		float3 sampleNormal = GBufferNormal(pixel);
		
		float weight = saturate(1.0 - abs(dot(plane, float4(sampleWorldPos, 1.0))) * _TangentWeight * rcpEyeDepth);
		weight *= saturate(1.0 - Angle(normal, sampleNormal) * _NormalWeight * rcpEyeDepth);
		
		result += UnpackInput(_Input[pixel]) * weight;
		weightSum += weight;
	}
	
	result /= weightSum;
	
	_Result[dispatchThreadId] = PackOutput(result);
	_Result[dispatchThreadId] = _Input[dispatchThreadId];
}

[numthreads(8, 8, 1)]
void Combine(uint2 dispatchThreadId : SV_DispatchThreadID)
{
	float2 uv = (dispatchThreadId + 0.5) * _ScreenSize.zw + _Jitter; // Re-jitter the output, as it will later be unjittered by taa resolve
	float4 result = UnpackInput(_Input.SampleLevel(_LinearClampSampler, uv, 0.0));
	
	// Remove weighting from final result
	result /= length(result.rgb);
	
	// Apply final modifier after temporal to reduce variance
	result.a = pow(result.a, _Strength);
	
	float4 visibilityCone = _VisibilityCone[dispatchThreadId];
	visibilityCone.xyz = GBufferNormal(visibilityCone);
	visibilityCone = BlendVisibiltyCones(visibilityCone, result);
	//visibilityCone = result;
	
	_VisibilityCone[dispatchThreadId] = PackGBufferNormal(visibilityCone.xyz, visibilityCone.w);
}